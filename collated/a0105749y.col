//@author: a0105749y



	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\common\Constants.java
	 */

	//Display
	public static final String MESSAGE_SHOW_ALL_TASKS = "ALL TASKS";
	public static final String MESSAGE_SHOW_INCOMPLETE_TASKS = "INCOMPLETE TASKS";
	public static final String MESSAGE_SHOW_FLOATING_TASKS = "FLOATING TASKS";
	public static final String MESSAGE_SHOW_DEADLINE_TASKS = "DEADLINE TASKS";
	public static final String MESSAGE_SHOW_TIMED_TASKS = "TIMED TASKS";
	public static final String MESSAGE_OUTPUT_TASKS = "%d. %s";
	public static final String MESSAGE_DISPLAY = "All tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_INCOMPLETE_TASKS = "All incomplete tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_INCOMPLETE_TASKS_PLURAL = "All incomplete tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_INCOMPLETE_TASKS_SINGULAR = "The incomplete task has been displayed.";
	public static final String MESSAGE_NO_INCOMPLETE_TASKS =  "All tasks are done.";
	public static final String MESSAGE_DISPLAY_FLOATING_TASKS = "All floating tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_FLOATING_TASKS_PLURAL = "All floating tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_FLOATING_TASKS_SINGULAR = "The floating task has been displayed.";
	public static final String MESSAGE_NO_FLOATING_TASKS =  "No floating task is found.";
	public static final String MESSAGE_DISPLAY_DEADLINE_TASKS = "All deadline tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_DEADLINE_TASKS_PLURAL = "All deadline tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_DEADLINE_TASKS_SINGULAR = "The deadline task has been displayed.";
	public static final String MESSAGE_NO_DEADLINE_TASKS =  "No deadline task is found";
	public static final String MESSAGE_DISPLAY_TIMED_TASKS = "All timed tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_TIMED_TASKS_PLURAL = "All timed tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_TIMED_TASKS_SINGULAR = "The timed task has been displayed.";
	public static final String MESSAGE_NO_TIMED_TASKS =  "No timed task is found";
	public static final String MESSAGE_DISPLAY_QUERY = "[%1$s's Tasks]";
	public static final String MESSAGE_COMPLETE_TASKS = "===COMPLETE    Tasks===";
	public static final String MESSAGE_INCOMPLETE_TASKS = "===INCOMPLETE Tasks===";
	public static final String MESSAGE_DISPLAY_TASKS_BY_DEADLINE = "Tasks end before [%1$s]";
	public static final String MESSAGE_DISPLAY_TASKS_IN_PERIOD = "Tasks from [%1$s] to [%2$s]";
	public static final String MESSAGE_EMPTY_LIST = "Your task list is empty.";
	public static final String MESSAGE_DISPLAY_IN_PERIOD = "This period's task(s) has(have) been displayed.";
	public static final String MESSAGE_DISPLAY_IN_PERIOD_PLURAL = "This period's tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_IN_PERIOD_SINGULAR = "This period's task has been displayed.";
	public static final String MESSAGE_NO_TASKS_IN_PERIOD = "No task is found in this period";
	public static final String TYPE_DISPLAY_INCOMPLETE = "";
	public static final String TYPE_DISPLAY_ALL = "all";
	public static final String TYPE_DISPLAY_FLOATING_TASK = "floating tasks";
	public static final String TYPE_DISPLAY_DEADLINE_TASK = "deadline tasks";
	public static final String TYPE_DISPLAY_TIMED_TASK = "timed tasks";
	
	// Search
	public final static String MESSAGE_RESULTS_FOUND = "Found: ";
    public final static String MESSAGE_MATCHING_ENTRIES = "All entries containing: '%s'";
    public final static String MESSAGE_SEARCH_FEEDBACK_PLURAL = "Tasks containing '%s' have been displayed.";
    public final static String MESSAGE_SEARCH_FEEDBACK_SINGULAR = "The task containing '%s' has been displayed.";
    public final static String ERROR_TASK_NOT_FOUND = "Cannot find any task about '%s'.";
    public static final String LOG_SEARCH_STARTED = "SEARCH Operating: Starting to sort events";

	//Update
	public static final String MESSAGE_TASK_NAME_UPDATED_SUCCESS = "Task name [%1$s] is updated to [%2$s] successfully.";
	public static final String MESSAGE_TASK_STARTTIME_UPDATED_SUCCESS = "Task No.%3$d [%1$s] start time is updated to [%2$s] successfully.";
	public static final String MESSAGE_TASK_ENDTIME_UPDATED_SUCCESS = "Task No.%3$d [%1$s] end  time is updated to [%2$s] successfully.";
	public static final String MESSAGE_TASK_TYPE_CHANGED = "No.%1$d [%3$s] [%2$s] TASK-TYPE changes to [%4$s]";
	public static final String MESSAGE_NO_TASK_TO_UPDATE = "Your list is empty! There is nothing to update.";
	public static final String MESSAGE_INEXISTANCE_SEQNO = "You have input an inexistence sequence number.";
	public static final String MESSAGE_ERROR_UPDATE_FLOATING = "Floating task cannot only update start time.";
	public static final String MESSAGE_NO_CHANGE = "Nothing has been updated";
	public static final String STRING_FLOATING_TASK = "TYPE FLOATING";
	public static final String STRING_DEADLINE_TASK = "TYPE DEADLINE";
	public static final String STRING_TIMED_TASK = "TYPE TIMED";
	public static final String STRING_UNSUPPORTED_TASK = "TYPE UNSUPPORTED";
    public static final String MESSAGE_UPDUATE_SUCCESSFUL = "Updated Sucessful!";
    public static final String MESSAGE_UPDATE_TIME_ERROR = "UPDATE ERROR: The task's end  time [%2$s] \r\n"
    		+ "                                                  is before/equal \r\n"
    		+ "                                             start time [%1$s].\r\n\r\n=*=*=*=UPDATE UNSUCCESSFUL!=*=*=*=";
	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\common\Constants.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Display.java
	 */

/**
 * This class is used to filter tasks by date, week, month or year
 */

import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Collections;

import clc.storage.Storage;
import static clc.common.Constants.*;

public class Display implements Command {
    private StringBuilder feedback = new StringBuilder();
    private String query;
    private String commandDetails = null;
    private Calendar startOfPeriod = null, endOfPeriod = null;
    private ArrayList<GregorianCalendar> time;
	private ArrayList<Task> internalMem;
	private ArrayList<Integer> displayMem;
	private ArrayList<Integer> internalMemCompleteTasks = new ArrayList<Integer>();
	private ArrayList<Integer> internalMemIncompleteTasks = new ArrayList<Integer>();
	
	public Display(ArrayList<GregorianCalendar> time) {
		this.time = time;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	}
	
	public Display(ArrayList<GregorianCalendar> time, String query) {
		this.time = time;
		this.query = query;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	}
	
	public Display(String commandDetails) {
		this. commandDetails = commandDetails;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	} 
	 
	@Override
	public String execute() {
		
		DisplayOutput.clear();
		displayMem.clear();
		sortTasks();
		
		if(internalMem.isEmpty()) {
			feedback.append(NEW_LINE);
			feedback = feedback.append(MESSAGE_EMPTY_LIST);
			feedback.append(NEW_LINE);
		} else if (commandDetails!= null) {
			
			switch (commandDetails){
			case TYPE_DISPLAY_INCOMPLETE:
				displayIncompleteTasks();
				break;
			case TYPE_DISPLAY_ALL:
				displayAllTasks();
				break;
			case TYPE_DISPLAY_FLOATING_TASK:
				displayFloatingTasks();
				break;	
			case TYPE_DISPLAY_DEADLINE_TASK:
				displayDeadlineTasks();
				break;
			case TYPE_DISPLAY_TIMED_TASK:
				displayTimedTasks();
				break;
			default:	
			    feedback.append(String.format(MESSAGE_INVALID_FORMAT, commandDetails));
			    
			}
			
		} else {
			displayInPeriod();
		}		
		assert feedback != null;
		return feedback.toString();
	}
	
	//display all tasks
	private void displayAllTasks(){
		DisplayOutput.add(MESSAGE_SHOW_ALL_TASKS);
		DisplayOutput.add(EMPTY_STRING);
		
	    for (int i = 1; i<= internalMem.size(); i++){
	    	Task task = internalMem.get(i - 1);
	    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, i, task.toString()));	
	    	displayMem.add(i - 1);
	    }
	    
	    feedback.append(NEW_LINE);
	    printOutDisplay();
	    feedback.append(NEW_LINE);
	    feedback.append(MESSAGE_DISPLAY);
	    feedback.append(NEW_LINE);
	}
	
	//display incomplete tasks
	private void displayIncompleteTasks(){
		int displayNo = 1;
		DisplayOutput.add(MESSAGE_SHOW_INCOMPLETE_TASKS);
		DisplayOutput.add(EMPTY_STRING);
		
		seprateTasksByCompletion();
	    for (int i = 1; i<= internalMemIncompleteTasks.size(); i++){
	    	int taskNo = internalMemIncompleteTasks.get(i - 1);
	    	Task task = internalMem.get(taskNo);
		    DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
		    displayMem.add(taskNo);
		    displayNo++;

	    }
	    feedback.append(NEW_LINE);
	    printOutDisplay();
	    
		// Process feedback
		if (getDataAmount() > 1) {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_DISPLAY_INCOMPLETE_TASKS_PLURAL);
			feedback.append(NEW_LINE);
		} else if (getDataAmount() == 1) {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_DISPLAY_INCOMPLETE_TASKS_SINGULAR);
			feedback.append(NEW_LINE);
		} else {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_NO_INCOMPLETE_TASKS);
			feedback.append(NEW_LINE);
		}
        
	}
	
	//display floating tasks
	private void displayFloatingTasks(){
		int displayNo = 1;
		DisplayOutput.add(MESSAGE_SHOW_FLOATING_TASKS);
		DisplayOutput.add(EMPTY_STRING);
		
	    for (int i = 1; i<= internalMem.size(); i++){
	    	Task task = internalMem.get(i - 1);
	    	if(task.getTaskType() == TYPE_FLOATING_TASK){
		    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
	    		displayMem.add(i - 1);
	    		displayNo++;
	    	}
	    }
	    
		feedback.append(NEW_LINE);
		printOutDisplay();
		
		// Process feedback
		if (getDataAmount() > 1) {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_DISPLAY_FLOATING_TASKS_PLURAL);
			feedback.append(NEW_LINE);
		} else if (getDataAmount() == 1) {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_DISPLAY_FLOATING_TASKS_SINGULAR);
			feedback.append(NEW_LINE);
		} else {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_NO_FLOATING_TASKS);
			feedback.append(NEW_LINE);
		}
	   
	}
	
	//display deadline tasks
	private void displayDeadlineTasks(){
		int displayNo = 1;
		DisplayOutput.add(MESSAGE_SHOW_DEADLINE_TASKS);
		DisplayOutput.add(EMPTY_STRING);
		
	    for (int i = 1; i<= internalMem.size(); i++){
	    	Task task = internalMem.get(i - 1);
	    	if(task.getTaskType() == TYPE_DEADLINE_TASK){
		    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
	    		displayMem.add(i - 1);
	    		displayNo++;
	    	}
	    }
	    
		feedback.append(NEW_LINE);
		printOutDisplay();
		
		// Process feedback
		if (getDataAmount() > 1) {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_DISPLAY_DEADLINE_TASKS_PLURAL);
			feedback.append(NEW_LINE);
		} else if (getDataAmount() == 1) {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_DISPLAY_DEADLINE_TASKS_SINGULAR);
			feedback.append(NEW_LINE);
		} else {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_NO_DEADLINE_TASKS);
			feedback.append(NEW_LINE);
		}
	   
	}
	
	//display timed tasks
	private void displayTimedTasks(){
		int displayNo = 1;
		DisplayOutput.add(MESSAGE_SHOW_TIMED_TASKS);
		DisplayOutput.add(EMPTY_STRING);

	    for (int i = 1; i<= internalMem.size(); i++){
	    	Task task = internalMem.get(i - 1);
	    	if(task.getTaskType() == TYPE_TIMED_TASK){
		    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
	    		displayMem.add(i - 1);
	    		displayNo++;
	    	}
	    }
	    
		feedback.append(NEW_LINE);
		printOutDisplay();
		
		// Process feedback
		if (getDataAmount() > 1) {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_DISPLAY_TIMED_TASKS_PLURAL);
			feedback.append(NEW_LINE);
		} else if (getDataAmount() == 1) {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_DISPLAY_TIMED_TASKS_SINGULAR);
			feedback.append(NEW_LINE);
		} else {
			feedback.append(NEW_LINE);
			feedback.append(MESSAGE_NO_TIMED_TASKS);
			feedback.append(NEW_LINE);
		}
	}

	
	private void displayInPeriod(){
			startOfPeriod = time.get(0);
			endOfPeriod = time.get(1);
			//Process output
			if(query != null){
				DisplayOutput.add(String.format(MESSAGE_DISPLAY_QUERY, query));
				DisplayOutput.add(EMPTY_STRING);
			} else if (startOfPeriod == null){
				String endTime = D_M_Y_DateFormatter.format(endOfPeriod.getTime());
				DisplayOutput.add(String.format(MESSAGE_DISPLAY_TASKS_BY_DEADLINE, endTime));
				DisplayOutput.add(EMPTY_STRING);
			} else {
				String startTime = D_M_Y_DateFormatter.format(startOfPeriod.getTime());
				String endTime = D_M_Y_DateFormatter.format(endOfPeriod.getTime());
				DisplayOutput.add(String.format(MESSAGE_DISPLAY_TASKS_IN_PERIOD, startTime, endTime));
				DisplayOutput.add(EMPTY_STRING);
			}
			goThroughTimePeriod(startOfPeriod, endOfPeriod);
			feedback.append(NEW_LINE);
			printOutDisplay();
			
			// Process feedback
			if (getDataAmount() > 1) {
				feedback.append(NEW_LINE);
				feedback.append(MESSAGE_DISPLAY_IN_PERIOD_PLURAL);
				feedback.append(NEW_LINE);
			} else if (getDataAmount() == 1) {
				feedback.append(NEW_LINE);
				feedback.append(MESSAGE_DISPLAY_IN_PERIOD_SINGULAR);
				feedback.append(NEW_LINE);
			} else {
				feedback.append(NEW_LINE);
				feedback.append(MESSAGE_NO_TASKS_IN_PERIOD);
				feedback.append(NEW_LINE);
			}
	
	}
	
	// Go through the internal memory and check whether the tasks are with in the time period
		private void goThroughTimePeriod(Calendar startOfPeriod, Calendar endOfPeriod) {
			seprateTasksByCompletion();
			if (startOfPeriod!= null && isWithinADay(startOfPeriod , endOfPeriod)){
				int displayNo = 1;
				DisplayOutput.add(MESSAGE_INCOMPLETE_TASKS);
				DisplayOutput.add(EMPTY_STRING);
				for (int i = 1; i <= internalMemIncompleteTasks.size(); i++) {
					int taskNo =  internalMemIncompleteTasks.get(i - 1);
					Task task = internalMem.get(taskNo);
					Calendar taskStartTime = task.getStartTime();
					Calendar taskEndTime = task.getEndTime();
					if (isWithinTimePeriod(startOfPeriod, endOfPeriod, taskStartTime, taskEndTime)) {
						DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toStringTimeFormatter()));	
						displayMem.add(i - 1);
					    displayNo++;
					}
				}	
				DisplayOutput.add(EMPTY_STRING);
				DisplayOutput.add(MESSAGE_COMPLETE_TASKS);
				DisplayOutput.add(EMPTY_STRING);
				for (int i = 1; i <= internalMemCompleteTasks.size(); i++) {
					int taskNo =  internalMemCompleteTasks.get(i - 1);
					Task task = internalMem.get(taskNo);
					Calendar taskStartTime = task.getStartTime();
					Calendar taskEndTime = task.getEndTime();
					if (isWithinTimePeriod(startOfPeriod, endOfPeriod, taskStartTime, taskEndTime)) {
						DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toStringTimeFormatter()));	
						displayMem.add(i - 1);
					    displayNo++;
					}
				}	
			} else {
				int displayNo = 1;
				DisplayOutput.add(MESSAGE_INCOMPLETE_TASKS);
				DisplayOutput.add(EMPTY_STRING);
				for (int i = 1; i <= internalMemIncompleteTasks.size(); i++) {
					int taskNo =  internalMemIncompleteTasks.get(i - 1);
					Task task = internalMem.get(taskNo);
					Calendar taskStartTime = task.getStartTime();
					Calendar taskEndTime = task.getEndTime();
					if (isWithinTimePeriod(startOfPeriod, endOfPeriod, taskStartTime, taskEndTime)) {
						DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));		
						displayMem.add(i - 1);
					    displayNo++;
					}
				}	
				DisplayOutput.add(EMPTY_STRING);
				DisplayOutput.add(MESSAGE_COMPLETE_TASKS);
				DisplayOutput.add(EMPTY_STRING);
				for (int i = 1; i <= internalMemCompleteTasks.size(); i++) {
					int taskNo =  internalMemCompleteTasks.get(i - 1);
					Task task = internalMem.get(taskNo);
					Calendar taskStartTime = task.getStartTime();
					Calendar taskEndTime = task.getEndTime();
					if (isWithinTimePeriod(startOfPeriod, endOfPeriod, taskStartTime, taskEndTime)) {
						DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
						displayMem.add(i - 1);
					    displayNo++;
					}
				}	
				
			}				
		}

		// check it is in the time period
		private boolean isWithinTimePeriod(Calendar startOfPeriod, Calendar endOfPeriod, Calendar taskStartTime, Calendar taskEndTime) {
			if (taskEndTime != null && endOfPeriod != null) {// check whether it is not a floating task, and it has an endOfPeriod
				if (taskStartTime == null && isTimeA_NotLater_Than_TimeB(taskEndTime, endOfPeriod)) {// check when it is a deadline task
					return (startOfPeriod == null || isTimeA_NotLater_Than_TimeB(startOfPeriod, taskEndTime));
				} else if (taskStartTime != null) { // check when it is a timed task
					if (startOfPeriod == null) { // check whether it is before deadline
						return isTimeA_NotLater_Than_TimeB(taskEndTime, endOfPeriod);
					} else {
						if (isTimeA_NotLater_Than_TimeB(taskStartTime, startOfPeriod)) {
							return (isTimeA_NotLater_Than_TimeB(startOfPeriod, taskEndTime) 
									&& isTimeA_NotLater_Than_TimeB(taskEndTime, endOfPeriod));
						} else {
							return isTimeA_NotLater_Than_TimeB(taskStartTime, endOfPeriod);
						}
					} 
				} else {
					return false;
				}
			} else {
				return false;
			}
		}
		
		private boolean isTimeA_NotLater_Than_TimeB(Calendar calA, Calendar calB){
			int i = calB.compareTo(calA);
			if (i > 0 || i == 0){
				return true;
			} else {
				return false;
			}
		}
		
		private void seprateTasksByCompletion() {
			internalMemCompleteTasks.clear();
			internalMemIncompleteTasks.clear();
			for(int i=1; i<=internalMem.size(); i++){
			    	Task task = internalMem.get(i - 1);
			    	if (!task.getIsDone()){
			    		internalMemIncompleteTasks.add(i-1);
			    	} else {
			    		internalMemCompleteTasks.add(i-1);
			    	}
			}
		}
		
		// Check whether the data which can be processed is empty
		protected int getDataAmount() {
			return displayMem.size();
		}
		
		protected boolean isWithinADay(Calendar calA, Calendar calB){
			   return calA.get(Calendar.YEAR) == calB.get(Calendar.YEAR)
			            && calA.get(Calendar.MONTH) == calB.get(Calendar.MONTH)
			            && (calA.get(Calendar.DAY_OF_MONTH) == calB.get(Calendar.DAY_OF_MONTH)
			            || (calA.get(Calendar.DAY_OF_MONTH) + 1 == calB.get(Calendar.DAY_OF_MONTH) 
			            && calB.get(Calendar.HOUR) == 0 && calB.get(Calendar.MINUTE) == 0 && calB.get(Calendar.SECOND) == 0));
		}
		
		protected void sortTasks() {
			Collections.sort(internalMem, new  TaskComparator());
		}
		
		
		protected void printOutDisplay(){
			for (int i = 0; i < DisplayOutput.size(); i++) {
				feedback.append(DisplayOutput.get(i));
				feedback.append(NEW_LINE);
				//System.out.println(DisplayOutput.get(i));
			}
		}
		

}

	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Display.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Search.java
	 */


import java.util.ArrayList;
import java.util.Collections;

import clc.storage.Storage;
import clc.common.LogHelper;
import static clc.common.Constants.MESSAGE_MATCHING_ENTRIES;
import static clc.common.Constants.MESSAGE_OUTPUT_TASKS;
import static clc.common.Constants.MESSAGE_RESULTS_FOUND;
import static clc.common.Constants.MESSAGE_DISPLAY;
import static clc.common.Constants.MESSAGE_SEARCH_FEEDBACK_PLURAL;
import static clc.common.Constants.MESSAGE_SEARCH_FEEDBACK_SINGULAR;
import static clc.common.Constants.ERROR_TASK_NOT_FOUND;
import static clc.common.Constants.EMPTY_STRING;
import static clc.common.Constants.NEW_LINE;
import static clc.common.Constants.DisplayOutput;
import static clc.common.Constants.LOG_SEARCH_STARTED;


public class Search implements Command {
	
	String commandDetails;
    private StringBuilder feedback = new StringBuilder();
	private ArrayList<Task> internalMem;
	private ArrayList<Integer> displayMem;
	
	public Search(String commandDetails){
		this.commandDetails = commandDetails;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	}
	public String execute() {
		searchAndprocessOutput();
		appendTaskSearchMessage(feedback, getFeedbackToUser());
		assert feedback != null;
		return feedback.toString();
	}
   
	// Search the internal memory for the keyword and process the output
	private void searchAndprocessOutput() {
		
	    //before searching DisplayOutput and displayMem must be cleared
		DisplayOutput.clear();
		displayMem.clear();
		DisplayOutput.add(String.format(MESSAGE_MATCHING_ENTRIES, commandDetails));
		DisplayOutput.add(EMPTY_STRING);
		
		LogHelper.info(LOG_SEARCH_STARTED);
		if (!internalMem.isEmpty()) {
			sortTasks();
			int displayNo = 1;
			for (int i = 0; i < internalMem.size(); i++) {
				Task task = internalMem.get(i);
				if (task.getTaskName().toLowerCase().contains(commandDetails.toLowerCase())) {
			    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
					displayMem.add(i);
					displayNo++;
				}	
			}
		}
		appendDisplayOutputMessage();
	}

	// Get the feedback according to the result of search
	private String getFeedbackToUser() {
		if (getDataAmount() > 0) {
			if (commandDetails.equals(EMPTY_STRING)) {
				return MESSAGE_RESULTS_FOUND + MESSAGE_DISPLAY;
			} else if (getDataAmount() > 1) {
				return MESSAGE_RESULTS_FOUND + String.format(MESSAGE_SEARCH_FEEDBACK_PLURAL, commandDetails);
			} else {
				return MESSAGE_RESULTS_FOUND + String.format(MESSAGE_SEARCH_FEEDBACK_SINGULAR, commandDetails);
			}
		} else {
			return String.format(ERROR_TASK_NOT_FOUND, commandDetails);
		}
	}
	
	private int getDataAmount() {
		return displayMem.size();
	}
	
	private void sortTasks() {
		Collections.sort(internalMem, new  TaskComparator());
	}
	
	private void appendTaskSearchMessage(StringBuilder feedback, String feedbackMessage) {
		feedback.append(NEW_LINE);
		feedback.append(feedbackMessage);
		feedback.append(NEW_LINE);
	}
	
	private void appendDisplayOutputMessage(){
		for (int i = 0; i < DisplayOutput.size(); i++) {
			feedback.append(DisplayOutput.get(i));
			feedback.append(NEW_LINE);
		}
	}
}

	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Search.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Task.java
	 */

	public String toString(){

		if(taskType == TYPE_TIMED_TASK){
			String startTimeString = D_M_Y_DateFormatter.format(startTime.getTime());
			String endTimeString = D_M_Y_DateFormatter.format(endTime.getTime());
			taskToString = String.format(TIMED_TASK_TO_STRING, taskName, startTimeString, endTimeString);
		}else if (taskType == TYPE_DEADLINE_TASK) {
			String endTimeString = D_M_Y_DateFormatter.format(endTime.getTime());
			taskToString = String.format(DEADLINE_TASK_TO_STRING, taskName, endTimeString);
		}else {
			taskToString = String.format(FLOATING_TASK_TO_STRING, taskName);
		}
		return taskToString;
	}

	public String toStringTimeFormatter(){
		if(taskType == TYPE_TIMED_TASK){
			String startTimeString = D_M_Y_TimeFormatter.format(startTime.getTime());
			String endTimeString = D_M_Y_TimeFormatter.format(endTime.getTime());
			taskToString = String.format(TIMED_TASK_TO_STRING, taskName, startTimeString, endTimeString);
		}else if (taskType == TYPE_DEADLINE_TASK) {
			String endTimeString = D_M_Y_TimeFormatter.format(endTime.getTime());
			taskToString = String.format(DEADLINE_TASK_TO_STRING, taskName, endTimeString);
		}else {
			taskToString = String.format(FLOATING_TASK_TO_STRING, taskName);
		}
		return taskToString;
	}

	public String taskTypeToString(){
		if(taskType == TYPE_TIMED_TASK){
			taskTypeToString = STRING_TIMED_TASK;
		}else if (taskType == TYPE_DEADLINE_TASK) {
			taskTypeToString = STRING_DEADLINE_TASK;
		}else if (taskType == TYPE_FLOATING_TASK){
			taskTypeToString = STRING_FLOATING_TASK;
		}else {
			taskTypeToString = STRING_UNSUPPORTED_TASK;
		}
		return taskTypeToString;
	}

	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Task.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Task.java
	 */

class TaskComparator implements Comparator<Task> {
	@Override
	public int compare(Task task1, Task task2) {
		if(task1.isFloatingTask()){
			if(task2.isFloatingTask()) {
				return task1.getTaskName().compareTo(task2.getTaskName());
			}
			else {
				return -1;
			}
		}
		else {
			if(task2.isFloatingTask()) {
				return 1;
			}
			else if(!task1.getEndTime().equals(task2.getEndTime())) {
				if(task1.getEndTime().before(task2.getEndTime())) {
					return -1;
				}
				else {
					return 1;
				}
			}
			else {
				return task1.getTaskName().compareTo(task2.getTaskName());
			}
		}
	}
}



	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Task.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Update.java
	 */

/**
 * This class is used to update new information to task.
 * 
 */

import static clc.common.Constants.*;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;

import clc.storage.History;
import clc.storage.Storage;


public class Update implements Command {
	
    private int seqNo;
    private int caseCalendarProvided;
    private Task task; 
    private String newTaskName = null;
    private StringBuilder feedback = new StringBuilder();
    private ArrayList<GregorianCalendar> time;
    private Calendar newStartTime = null, newEndTime = null;
    private ArrayList<Integer> displayMem;
    private ArrayList<Task> internalMem;
   
	//constructor
	public Update(int seqNo, String newTaskName) {
		this.seqNo = seqNo;
		this.newTaskName = newTaskName;
		displayMem = Storage.getDisplayMem();
		internalMem = Storage.getInternalMem();
	}
	public Update(int seqNo, int caseCalendarProvided, ArrayList<GregorianCalendar> time){
		this.seqNo = seqNo;
		this.caseCalendarProvided = caseCalendarProvided;
		this.time = time;
		newStartTime = time.get(0);
		newEndTime = time.get(1);
		displayMem = Storage.getDisplayMem();
		internalMem = Storage.getInternalMem();
	}
	
	@Override
	public String execute() {
		if (isDataEmpty()) {
			appendTaskUpdatedMessage(feedback, MESSAGE_NO_TASK_TO_UPDATE);
			
		} else if (isOutOfBound()) {
			appendTaskUpdatedMessage(feedback, MESSAGE_INEXISTANCE_SEQNO);
			
		} else {
			int internalSeqNo = displayMem.get(seqNo - 1);
			task = internalMem.get(internalSeqNo);
            updateTask();
            
            //have a backup for undo
    		History.addNewVersion();
    		Storage.writeContentIntoFile();
		}
		
		assert feedback != null;
		return feedback.toString();
	}
	
	private void updateTask(){
		
		String taskName = task.getTaskName();
		int taskOldType = task.getTaskType();
		String taskOldTypeString = task.taskTypeToString();
        Calendar taskOldStartTime = task.getStartTime(); 
		Calendar taskOldEndTime = task.getEndTime();
		
		Calendar updateTime = null;
		Calendar floatingTaskStartTime = null;
		
		//for checking start time >= end time
		Calendar startTimeForChecking = null;
		Calendar endTimeForChecking = null;
		
		//update name
		if (isUpdatedNameCase(newTaskName)){
			updateTaskName(taskName, newTaskName);
		}
		
		//update start time
		if (isUpdatedStartTimeCase(newStartTime)){
			
			if (taskOldType == TYPE_TIMED_TASK){//for timed task
				//update date
				if (isStartDateUpdated(caseCalendarProvided)) {
					updateTime = updateNewDate(taskOldStartTime, newStartTime);
				    task.setStartTime(updateTime);
				    caseCalendarProvided -= 8;
				} 
				//update time
				if (isStartTimeUpdated(caseCalendarProvided)) {
					updateTime = task.getStartTime();
					updateTime = updateNewTime(updateTime, newStartTime);
				    task.setStartTime(updateTime);
				    caseCalendarProvided -= 4;
				}
				taskName = task.getTaskName();
				//process feedback
				String startTime = D_M_Y_DateFormatter.format(updateTime.getTime());
				feedback.append(String.format(MESSAGE_TASK_STARTTIME_UPDATED_SUCCESS, taskName, startTime, seqNo));
				feedback.append(NEWLINE);
				
			} else if (taskOldType == TYPE_DEADLINE_TASK){//for deadline task
				task.setStartTime(newStartTime);
				updateTime = task.getStartTime();
				task.setTaskType(TYPE_TIMED_TASK);
				caseCalendarProvided %= 4;
				
				//process feedback
				String startTime = D_M_Y_DateFormatter.format(updateTime.getTime());
				feedback.append(String.format(MESSAGE_TASK_STARTTIME_UPDATED_SUCCESS, taskName, startTime, seqNo));
				feedback.append(NEWLINE);

				
			} else {//for floating task
				if(newEndTime != null){
					task.setStartTime(newStartTime);
					updateTime = task.getStartTime();
					//task.setTaskType(TYPE_DEADLINE_TASK);
					
					//process feedback
					String startTime = D_M_Y_DateFormatter.format(updateTime.getTime());
					feedback.append(String.format(MESSAGE_TASK_STARTTIME_UPDATED_SUCCESS, taskName, startTime, seqNo));
					feedback.append(NEWLINE);
				} else {
					
					//process feedback
					feedback.append(MESSAGE_ERROR_UPDATE_FLOATING);
					feedback.append(NEWLINE);
				}
			}
			
		}
		
		//update end time
		//System.out.println(newEndTime.getTime());
        //System.out.println(caseCalendarProvided);
		if (isUpdatedEndTimeCase(newEndTime)) {
			if (taskOldType == TYPE_FLOATING_TASK){//for floating task
				floatingTaskStartTime = task.getStartTime();
				if (floatingTaskStartTime == null){
					task.setEndTime(newEndTime);
					updateTime = task.getEndTime();
					task.setTaskType(TYPE_DEADLINE_TASK);
					
					//process feedback
					String endTime = D_M_Y_DateFormatter.format(updateTime.getTime());
					feedback.append(String.format(MESSAGE_TASK_ENDTIME_UPDATED_SUCCESS, taskName, endTime, seqNo));
					feedback.append(NEWLINE);

					
				} else {
					task.setEndTime(newEndTime);
					updateTime = task.getEndTime();
					task.setTaskType(TYPE_TIMED_TASK);
					
					//process feedback
					String endTime = D_M_Y_DateFormatter.format(updateTime.getTime());
					feedback.append(String.format(MESSAGE_TASK_ENDTIME_UPDATED_SUCCESS, taskName, endTime, seqNo));
					feedback.append(NEWLINE);
					
				}
			} else { // for deadline & timed task
				
				//update date
				if (isEndDateUpdated(caseCalendarProvided)) {
					updateTime = updateNewDate(taskOldEndTime, newEndTime);
				    task.setEndTime(updateTime);
				    caseCalendarProvided -= 2;
				} 
				
				//update time
				if (isEndTimeUpdated(caseCalendarProvided)) {
					updateTime = task.getEndTime();
					updateTime = updateNewTime(updateTime, newEndTime);
				    task.setEndTime(updateTime);
				}
				
				// process feedback
				taskName = task.getTaskName();
				String endTime = D_M_Y_DateFormatter.format(updateTime.getTime());
				//System.out.println(endTime);
				feedback.append(String.format(MESSAGE_TASK_ENDTIME_UPDATED_SUCCESS, taskName, endTime, seqNo));
				feedback.append(NEWLINE);
			}
		} 
		
		//check if task type changed
		int taskNewType = task.getTaskType();
		String taskNewTypeString = task.taskTypeToString();
		if(isTaskTypeChanged(taskOldType, taskNewType)){
			appendTaskTypeChangedMessage(feedback, seqNo, taskName, taskOldTypeString, taskNewTypeString);
		}
		
        //check if startTime before endTime
		startTimeForChecking = task.getStartTime();
		endTimeForChecking = task.getEndTime();
		
		if (isStartTimeLaterThanEndTime(startTimeForChecking, endTimeForChecking)) {
			
			String startTimeC = D_M_Y_DateFormatter.format(startTimeForChecking.getTime());
			String endTimeC = D_M_Y_DateFormatter.format(endTimeForChecking.getTime());
			
			task.setStartTime(taskOldStartTime);
			task.setEndTime(taskOldEndTime);
			task.setTaskType(taskOldType);
			
			feedback.append(NEWLINE);
			feedback.append(String.format(MESSAGE_UPDATE_TIME_ERROR, startTimeC, endTimeC));
			feedback.append(NEWLINE);
		}
		
		//check if nothing changes
		if(newTaskName == null && newStartTime == null && newEndTime == null){
			appendTaskUpdatedMessage(feedback, MESSAGE_NO_CHANGE);
		}
	}
	
	private GregorianCalendar updateNewDate(Calendar oldTime, Calendar newTime) {
		int year = newTime.get(Calendar.YEAR);
	 	int month =	newTime.get(Calendar.MONTH);	
		int date = newTime.get(Calendar.DATE);
		int hour = oldTime.get(Calendar.HOUR_OF_DAY);
		int minute = oldTime.get(Calendar.MINUTE);
		GregorianCalendar dateUpdated = new GregorianCalendar(year, month, date, hour, minute);
		return dateUpdated;
	}
	
	private GregorianCalendar updateNewTime(Calendar oldTime, Calendar newTime){
	    return updateNewDate(newTime, oldTime);
	}
	
	private void updateTaskName(String taskOldName, String taskNewName){
            task.setTaskName(taskNewName);
            appendTaskUpdatedNewNameMessage(feedback, taskOldName, taskNewName);
	} 
	
    //append feedback method
	private void appendTaskUpdatedMessage(StringBuilder feedback, String message) {
		feedback.append(message);
		feedback.append(NEWLINE);
	}
	
	private void appendTaskTypeChangedMessage(StringBuilder feedback, int seqNo, String taskName, String taskOldType, String taskNewType) {
		feedback.append(NEWLINE);
		feedback.append(String.format(MESSAGE_TASK_TYPE_CHANGED, seqNo ,taskName, taskOldType, taskNewType));
		feedback.append(NEWLINE);
	}
	
	private void appendTaskUpdatedNewNameMessage(StringBuilder feedback, String taskOldName, String taskNewName) {
	       feedback.append(String.format(MESSAGE_TASK_NAME_UPDATED_SUCCESS, taskOldName, taskNewName));
           feedback.append(NEWLINE);
	}
	

	// Check whether the data which can be processed is empty
	private boolean isDataEmpty() {
		return displayMem.isEmpty();
	}
	
	private boolean isOutOfBound() {
		return seqNo > displayMem.size();
	}
	
	private boolean isStartTimeLaterThanEndTime(Calendar startTime, Calendar endTime) {
		return startTime != null && startTime.compareTo(endTime) >= 0;
	}
	
	private boolean isTaskTypeChanged(int taskOldType, int taskNewType) {
		return taskOldType != taskNewType;
	}
	
	private boolean isUpdatedNameCase(String taskNewName){
		return taskNewName != null;
	}
	
	private boolean isUpdatedStartTimeCase(Calendar newStartTime){
		return newStartTime != null;
	}
	
	private boolean isUpdatedEndTimeCase(Calendar newEndTime){
		return newEndTime != null;
	}
	
	private boolean isStartDateUpdated(int caseCalendarProvided) {
		return caseCalendarProvided/8 == 1;
	}
	
	private boolean isStartTimeUpdated(int caseCalendarProvided) {
		return caseCalendarProvided/4 == 1;
	}
	
	private boolean isEndDateUpdated(int caseCalendarProvided) {
		return caseCalendarProvided/2 == 1;
	}
	private boolean isEndTimeUpdated(int caseCalendarProvided) {
		return caseCalendarProvided == 1;
	}
}	

	
	
	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Update.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\storage\Storage.java
	 */

	/**
	 * Create the data file if it does not exist. 
	 * Otherwise read in the content from the data file.
	 */
	
	public static void initializeDataFile() {
		dataFile = new File(OUTFILE);
		if (!dataFile.exists()) {
			// Create the file if it does not exist
			try {
				dataFile.createNewFile();
				LogHelper.info(String.format(LOG_DATA_FILE_CREATED, dataFile.getPath()));
			} catch (IOException e) {
				LogHelper.severe(e.getMessage());
			}
		} else {
			try {
				readContentFromFile(OUTFILE);
			} catch (Exception e) {
				LogHelper.severe(e.getMessage());
			}
		}
		
		assert dataFile.exists();
	}
	
	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\storage\Storage.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\storage\Storage.java
	 */

	/**
	 * Read from the Help.txt and return to string
	 * @param fileName The file name of help manual file
	 * @return The contents of the help manual file
	 */
	public static String readManualFromHelpFile(String fileName) {
		InputStream in = Storage.class.getResourceAsStream(fileName);
		
		StringBuilder sb = new StringBuilder();
		try {

			BufferedReader bf = new BufferedReader(new InputStreamReader(in));
			String contentToRead = null;

			while((contentToRead = bf.readLine()) != null) {
				sb.append(contentToRead);
				sb.append(NEWLINE);
			}

			bf.close();
			LogHelper.info(String.format(LOG_DATA_FILE_READ, fileName));
		} catch (IOException e) {
			LogHelper.severe(e.getMessage());
		}
		return sb.toString();
	}
	
	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\storage\Storage.java





