//@author: a0105749y



	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\common\Constants.java
	 */

	//Display
	public static final String MESSAGE_SHOW_ALL_TASKS = "ALL TASKS";
	public static final String MESSAGE_SHOW_INCOMPLETE_TASKS = "INCOMPLETE TASKS";
	public static final String MESSAGE_SHOW_FLOATING_TASKS = "FLOATING TASKS";
	public static final String MESSAGE_SHOW_DEADLINE_TASKS = "DEADLINE TASKS";
	public static final String MESSAGE_SHOW_TIMED_TASKS = "TIMED TASKS";
	public static final String MESSAGE_OUTPUT_TASKS = "%d. %s";
	public static final String MESSAGE_DISPLAY = "All tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_INCOMPLETE_TASKS = "All incomplete tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_INCOMPLETE_TASKS_PLURAL = "All incomplete tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_INCOMPLETE_TASKS_SINGULAR = "The incomplete task has been displayed.";
	public static final String MESSAGE_NO_INCOMPLETE_TASKS =  "All tasks are done.";
	public static final String MESSAGE_DISPLAY_FLOATING_TASKS = "All floating tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_FLOATING_TASKS_PLURAL = "All floating tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_FLOATING_TASKS_SINGULAR = "The floating task has been displayed.";
	public static final String MESSAGE_NO_FLOATING_TASKS =  "No floating task is found.";
	public static final String MESSAGE_DISPLAY_DEADLINE_TASKS = "All deadline tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_DEADLINE_TASKS_PLURAL = "All deadline tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_DEADLINE_TASKS_SINGULAR = "The deadline task has been displayed.";
	public static final String MESSAGE_NO_DEADLINE_TASKS =  "No deadline task is found";
	public static final String MESSAGE_DISPLAY_TIMED_TASKS = "All timed tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_TIMED_TASKS_PLURAL = "All timed tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_TIMED_TASKS_SINGULAR = "The timed task has been displayed.";
	public static final String MESSAGE_NO_TIMED_TASKS =  "No timed task is found";
	public static final String MESSAGE_DISPLAY_QUERY = "[%1$s's Tasks]";
	public static final String MESSAGE_COMPLETE_TASKS = "===COMPLETE    Tasks===";
	public static final String MESSAGE_INCOMPLETE_TASKS = "===INCOMPLETE Tasks===";
	public static final String MESSAGE_DISPLAY_TASKS_BY_DEADLINE = "Tasks end before [%1$s]";
	public static final String MESSAGE_DISPLAY_TASKS_IN_PERIOD = "Tasks from [%1$s] to [%2$s]";
	public static final String MESSAGE_EMPTY_LIST = "Your task list is empty.";
	public static final String MESSAGE_DISPLAY_IN_PERIOD = "This period's task(s) has(have) been displayed.";
	public static final String MESSAGE_DISPLAY_IN_PERIOD_PLURAL = "This period's tasks have been displayed.";
	public static final String MESSAGE_DISPLAY_IN_PERIOD_SINGULAR = "This period's task has been displayed.";
	public static final String MESSAGE_NO_TASKS_IN_PERIOD = "No task is found in this period";
	public static final String TYPE_DISPLAY_INCOMPLETE = "";
	public static final String TYPE_DISPLAY_ALL = "all";
	public static final String TYPE_DISPLAY_FLOATING_TASK = "floating tasks";
	public static final String TYPE_DISPLAY_DEADLINE_TASK = "deadline tasks";
	public static final String TYPE_DISPLAY_TIMED_TASK = "timed tasks";
	public static final String LOG_DISPLAY_STARTED = "DISPLAY Operating: Starting to fliter tasks";
	// Search
	public final static String MESSAGE_RESULTS_FOUND = "Found: ";
    public final static String MESSAGE_MATCHING_ENTRIES = "All entries containing: '%s'";
    public final static String MESSAGE_SEARCH_FEEDBACK_PLURAL = "Tasks containing '%s' have been displayed.";
    public final static String MESSAGE_SEARCH_FEEDBACK_SINGULAR = "The task containing '%s' has been displayed.";
    public final static String ERROR_TASK_NOT_FOUND = "Cannot find any task about '%s'.";
    public static final String LOG_SEARCH_STARTED = "SEARCH Operating: Starting to sort tasks";

	//Update
	public static final String MESSAGE_TASK_NAME_UPDATED_SUCCESS = "Task name [%1$s] is updated to [%2$s] successfully.";
	public static final String MESSAGE_TASK_STARTTIME_UPDATED_SUCCESS = "Task No.%3$d [%1$s] start time is updated to [%2$s] successfully.";
	public static final String MESSAGE_TASK_ENDTIME_UPDATED_SUCCESS = "Task No.%3$d [%1$s] end  time is updated to [%2$s] successfully.";
	public static final String MESSAGE_TASK_TYPE_CHANGED = "No.%1$d [%2$s] task type from [%3$s] changes to [%4$s]";
	public static final String MESSAGE_NO_TASK_TO_UPDATE = "Your list is empty! There is nothing to update.";
	public static final String MESSAGE_INEXISTANCE_SEQNO = "You have input an inexistence sequence number.";
	public static final String MESSAGE_NO_CHANGE = "Nothing has been updated";
	public static final String STRING_FLOATING_TASK = "TYPE FLOATING";
	public static final String STRING_DEADLINE_TASK = "TYPE DEADLINE";
	public static final String STRING_TIMED_TASK = "TYPE TIMED";
	public static final String STRING_UNSUPPORTED_TASK = "TYPE UNSUPPORTED";
    public static final String MESSAGE_UPDUATE_SUCCESSFUL = "Updated Sucessful!";
	public static final String MESSAGE_FLOATING_TASK_UPDATED_ERROR = "UPDATE ERROR: Floating task cannot only update start time.";
    public static final String MESSAGE_UPDATE_TIME_ERROR = "UPDATE ERROR: Task end time is before or equal to start time.";
    
	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\common\Constants.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Display.java
	 */

/**
 * This class is used to filter tasks by date, week, month or year
 */

import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Collections;

import clc.common.InvalidInputException;
import clc.common.LogHelper;
import clc.storage.Storage;
import static clc.common.Constants.*;


public class Display implements Command {
    private StringBuilder feedback = new StringBuilder();
    private String query;
    private String commandDetails = null;
    private Calendar startOfPeriod = null, endOfPeriod = null;
    private ArrayList<GregorianCalendar> time;
	private ArrayList<Task> internalMem;
	private ArrayList<Integer> displayMem;
	private ArrayList<Integer> internalMemCompleteTasks = new ArrayList<Integer>();
	private ArrayList<Integer> internalMemIncompleteTasks = new ArrayList<Integer>();
	
	public Display(ArrayList<GregorianCalendar> time) {
		this.time = time;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	}
	
	public Display(String commandDetails) {
		this. commandDetails = commandDetails;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	} 
	 
	public Display(ArrayList<GregorianCalendar> time, String query) {
		this.time = time;
		this.query = query;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	}
	
	@Override
	public String execute() {
		
		DisplayOutput.clear();
		displayMem.clear();
		sortTasks();
		
		LogHelper.info(LOG_DISPLAY_STARTED);
		try {
			if(internalMem.isEmpty()) {
				appendTaskDisplayMessage(feedback, MESSAGE_EMPTY_LIST);
				
			} else if (commandDetails!= null) {
				
				switch (commandDetails){
				case TYPE_DISPLAY_INCOMPLETE:
					displayIncompleteTasks();
					break;
				case TYPE_DISPLAY_ALL:
					displayAllTasks();
					break;
				case TYPE_DISPLAY_FLOATING_TASK:
					displayFloatingTasks();
					break;	
				case TYPE_DISPLAY_DEADLINE_TASK:
					displayDeadlineTasks();
					break;
				case TYPE_DISPLAY_TIMED_TASK:
					displayTimedTasks();
					break;
				default:	
					LogHelper.warning("User inputs invalid command details for display function");
					throw new InvalidInputException(String.format(MESSAGE_INVALID_FORMAT, commandDetails));
				    //feedback.append(String.format(MESSAGE_INVALID_FORMAT, commandDetails)); 
				}
				
			} else {
				displayInPeriod();
			} 
		} catch (InvalidInputException iie) {
				return iie.getMessage();
		}
		
		assert feedback != null;
		return feedback.toString();
	}
	
	//display all tasks
	private void displayAllTasks(){
		appendTaskDisplayMessage(feedback, MESSAGE_SHOW_ALL_TASKS);
		
	    for (int i = 1; i<= internalMem.size(); i++){
	    	Task task = internalMem.get(i - 1);
	    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, i, task.toString()));	
	    	displayMem.add(i - 1);
	    }
	    
	    appendDisplayOutputMessage();
		appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY);
	}
	
	//display incomplete tasks
	private void displayIncompleteTasks(){
		int displayNo = 1;
		appendTaskDisplayMessage(feedback, MESSAGE_SHOW_INCOMPLETE_TASKS);
		
		seprateTasksByCompletion();
		
	    for (int i = 1; i<= internalMemIncompleteTasks.size(); i++){
	    	int taskNo = internalMemIncompleteTasks.get(i - 1);
	    	Task task = internalMem.get(taskNo);
		    DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
		    displayMem.add(taskNo);
		    displayNo++;
	    }
	    appendDisplayOutputMessage();
	    
		// Process feedback
		if (getDataAmount() > 1) {
			appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_INCOMPLETE_TASKS_PLURAL);
		} else if (getDataAmount() == 1) {
			appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_INCOMPLETE_TASKS_SINGULAR);
		} else {
			appendTaskDisplayMessage(feedback, MESSAGE_NO_INCOMPLETE_TASKS);
		}  
	}
	
	//display floating tasks
	private void displayFloatingTasks(){
		int displayNo = 1;
		appendTaskDisplayMessage(feedback, MESSAGE_SHOW_FLOATING_TASKS);
		
	    for (int i = 1; i<= internalMem.size(); i++){
	    	Task task = internalMem.get(i - 1);
	    	if(task.getTaskType() == TYPE_FLOATING_TASK){
		    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
	    		displayMem.add(i - 1);
	    		displayNo++;
	    	}
	    }
		appendDisplayOutputMessage();
		
		// Process feedback
		if (getDataAmount() > 1) {
			appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_FLOATING_TASKS_PLURAL);
		} else if (getDataAmount() == 1) {
			appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_FLOATING_TASKS_SINGULAR);
		} else {
			appendTaskDisplayMessage(feedback, MESSAGE_NO_FLOATING_TASKS);
		}
	   
	}
	
	//display deadline tasks
	private void displayDeadlineTasks(){
		int displayNo = 1;
		appendTaskDisplayMessage(feedback,MESSAGE_SHOW_DEADLINE_TASKS);
		
	    for (int i = 1; i<= internalMem.size(); i++){
	    	Task task = internalMem.get(i - 1);
	    	if(task.getTaskType() == TYPE_DEADLINE_TASK){
		    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
	    		displayMem.add(i - 1);
	    		displayNo++;
	    	}
	    }
		appendDisplayOutputMessage();
		
		// Process feedback
		if (getDataAmount() > 1) {
			appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_DEADLINE_TASKS_PLURAL);
		} else if (getDataAmount() == 1) {
			appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_DEADLINE_TASKS_SINGULAR);
		} else {
			appendTaskDisplayMessage(feedback, MESSAGE_NO_DEADLINE_TASKS);
		}
	}
	
	//display timed tasks
	private void displayTimedTasks(){
		int displayNo = 1;
		appendTaskDisplayMessage(feedback, MESSAGE_SHOW_TIMED_TASKS);

	    for (int i = 1; i<= internalMem.size(); i++){
	    	Task task = internalMem.get(i - 1);
	    	if(task.getTaskType() == TYPE_TIMED_TASK){
		    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
	    		displayMem.add(i - 1);
	    		displayNo++;
	    	}
	    }
		appendDisplayOutputMessage();
		
		// Process feedback
		if (getDataAmount() > 1) {
			appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_TIMED_TASKS_PLURAL);
		} else if (getDataAmount() == 1) {
			appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_TIMED_TASKS_SINGULAR);
		} else {
			appendTaskDisplayMessage(feedback, MESSAGE_NO_TIMED_TASKS);
		}
	}

	
	private void displayInPeriod(){
			startOfPeriod = time.get(0);
			endOfPeriod = time.get(1);
			
			//Process display start message
			if(query != null){
				appendTaskDisplayMessage(feedback, String.format(MESSAGE_DISPLAY_QUERY, query));
			} else if (startOfPeriod == null){
				
				String endTime = D_M_Y_DateFormatter.format(endOfPeriod.getTime());
				appendTaskDisplayMessage(feedback,String.format(MESSAGE_DISPLAY_TASKS_BY_DEADLINE, endTime));
			} else {
				
				String startTime = D_M_Y_DateFormatter.format(startOfPeriod.getTime());
				String endTime = D_M_Y_DateFormatter.format(endOfPeriod.getTime());
				appendTaskDisplayMessage(feedback,String.format(MESSAGE_DISPLAY_TASKS_IN_PERIOD, startTime, endTime));
			}
			
			goThroughTimePeriod(startOfPeriod, endOfPeriod);
			appendDisplayOutputMessage();
			
			// Process feedback
			if (getDataAmount() > 1) {
				appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_IN_PERIOD_PLURAL);
			} else if (getDataAmount() == 1) {
				appendTaskDisplayMessage(feedback, MESSAGE_DISPLAY_IN_PERIOD_SINGULAR);
			} else {
				appendTaskDisplayMessage(feedback, MESSAGE_NO_TASKS_IN_PERIOD);
			}
	
	}
	
	// Go through the internal memory and check whether the tasks are with in the time period
	private void goThroughTimePeriod(Calendar startOfPeriod, Calendar endOfPeriod) {
		seprateTasksByCompletion();
		if (startOfPeriod!= null && isWithinADay(startOfPeriod , endOfPeriod)){
			int displayNo = 1;
			addDisplayMessage(DisplayOutput, MESSAGE_INCOMPLETE_TASKS);
			
			for (int i = 1; i <= internalMemIncompleteTasks.size(); i++) {
				int taskNo =  internalMemIncompleteTasks.get(i - 1);
				Task task = internalMem.get(taskNo);
				Calendar taskStartTime = task.getStartTime();
				Calendar taskEndTime = task.getEndTime();
				if (isWithinTimePeriod(startOfPeriod, endOfPeriod, taskStartTime, taskEndTime)) {
					DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toStringTimeFormatter()));	
					displayMem.add(i - 1);
				    displayNo++;
				}
			}	
			addDisplayOutputMessage(DisplayOutput, MESSAGE_COMPLETE_TASKS);
			
			for (int i = 1; i <= internalMemCompleteTasks.size(); i++) {
				int taskNo =  internalMemCompleteTasks.get(i - 1);
				Task task = internalMem.get(taskNo);
				Calendar taskStartTime = task.getStartTime();
				Calendar taskEndTime = task.getEndTime();
				if (isWithinTimePeriod(startOfPeriod, endOfPeriod, taskStartTime, taskEndTime)) {
					DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toStringTimeFormatter()));	
					displayMem.add(i - 1);
				    displayNo++;
				}
			}	
		} else {
			int displayNo = 1;
			addDisplayMessage(DisplayOutput, MESSAGE_INCOMPLETE_TASKS);
			
			for (int i = 1; i <= internalMemIncompleteTasks.size(); i++) {
				int taskNo =  internalMemIncompleteTasks.get(i - 1);
				Task task = internalMem.get(taskNo);
				Calendar taskStartTime = task.getStartTime();
				Calendar taskEndTime = task.getEndTime();
				if (isWithinTimePeriod(startOfPeriod, endOfPeriod, taskStartTime, taskEndTime)) {
					DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));		
					displayMem.add(i - 1);
				    displayNo++;
				}
			}	
			addDisplayOutputMessage(DisplayOutput, MESSAGE_COMPLETE_TASKS);
			
			for (int i = 1; i <= internalMemCompleteTasks.size(); i++) {
				int taskNo =  internalMemCompleteTasks.get(i - 1);
				Task task = internalMem.get(taskNo);
				Calendar taskStartTime = task.getStartTime();
				Calendar taskEndTime = task.getEndTime();
				if (isWithinTimePeriod(startOfPeriod, endOfPeriod, taskStartTime, taskEndTime)) {
					DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
					displayMem.add(i - 1);
				    displayNo++;
				}
			}	
			
		}				
	}
	// check it is in the time period
	private boolean isWithinTimePeriod(Calendar startOfPeriod, Calendar endOfPeriod, Calendar taskStartTime, Calendar taskEndTime) {
		if (taskEndTime != null && endOfPeriod != null) {// check whether it is not a floating task, and it has an endOfPeriod
			if (taskStartTime == null && isTimeBLaterOrEqualThanTimeA(taskEndTime, endOfPeriod)) {// check when it is a deadline task
				return (startOfPeriod == null || isTimeBLaterOrEqualThanTimeA(startOfPeriod, taskEndTime));
			} else if (taskStartTime != null) { // check when it is a timed task
				if (startOfPeriod == null) { // check whether it is before deadline
					return isTimeBLaterOrEqualThanTimeA(taskEndTime, endOfPeriod);
				} else {
					if (isTimeBLaterOrEqualThanTimeA(taskStartTime, startOfPeriod)) {
						return (isTimeBLaterOrEqualThanTimeA(startOfPeriod, taskEndTime) 
								&& isTimeBLaterOrEqualThanTimeA(taskEndTime, endOfPeriod));
					} else {
						return isTimeBLaterOrEqualThanTimeA(taskStartTime, endOfPeriod);
					}
				} 
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	
	private boolean isTimeBLaterOrEqualThanTimeA(Calendar calA, Calendar calB){
		int i = calB.compareTo(calA);
		if (i > 0 || i == 0){
			return true;
		} else {
			return false;
		}
	}
	
	private void seprateTasksByCompletion() {
		internalMemCompleteTasks.clear();
		internalMemIncompleteTasks.clear();
		for(int i=1; i<=internalMem.size(); i++){
		    	Task task = internalMem.get(i - 1);
		    	if (!task.getIsDone()){
		    		internalMemIncompleteTasks.add(i-1);
		    	} else {
		    		internalMemCompleteTasks.add(i-1);
		    	}
		}
	}
	
	// Check whether the data which can be processed is empty
	private int getDataAmount() {
		return displayMem.size();
	}
	
	private boolean isWithinADay(Calendar calA, Calendar calB){
		   return calA.get(Calendar.YEAR) == calB.get(Calendar.YEAR)
		            && calA.get(Calendar.MONTH) == calB.get(Calendar.MONTH)
		            && (calA.get(Calendar.DAY_OF_MONTH) == calB.get(Calendar.DAY_OF_MONTH)
		            || (calA.get(Calendar.DAY_OF_MONTH) + 1 == calB.get(Calendar.DAY_OF_MONTH) 
		            && calB.get(Calendar.HOUR) == 0 && calB.get(Calendar.MINUTE) == 0 && calB.get(Calendar.SECOND) == 0));
	}
	
	private void sortTasks() {
		Collections.sort(internalMem, new  TaskComparator());
	}
	
	//append feedback method
	private void appendDisplayOutputMessage(){
	    feedback.append(NEW_LINE);
		for (int i = 0; i < DisplayOutput.size(); i++) {
			feedback.append(DisplayOutput.get(i));
			feedback.append(NEW_LINE);
		}
	}
	
	private void appendTaskDisplayMessage(StringBuilder feedback, String feedbackMessage){
		feedback.append(NEW_LINE);
		feedback = feedback.append(feedbackMessage);
		feedback.append(NEW_LINE);
	}

	private void addDisplayMessage(ArrayList<String> DisplayOutput, String message){
		DisplayOutput.add(message);
		DisplayOutput.add(EMPTY_STRING);
	}
	
	private void addDisplayOutputMessage(ArrayList<String> DisplayOutput, String message){
		DisplayOutput.add(EMPTY_STRING);
		DisplayOutput.add(message);
		DisplayOutput.add(EMPTY_STRING);
	}	
}

	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Display.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Search.java
	 */


import java.util.ArrayList;
import java.util.Collections;

import clc.storage.Storage;
import clc.common.LogHelper;
import static clc.common.Constants.MESSAGE_MATCHING_ENTRIES;
import static clc.common.Constants.MESSAGE_OUTPUT_TASKS;
import static clc.common.Constants.MESSAGE_RESULTS_FOUND;
import static clc.common.Constants.MESSAGE_DISPLAY;
import static clc.common.Constants.MESSAGE_SEARCH_FEEDBACK_PLURAL;
import static clc.common.Constants.MESSAGE_SEARCH_FEEDBACK_SINGULAR;
import static clc.common.Constants.ERROR_TASK_NOT_FOUND;
import static clc.common.Constants.EMPTY_STRING;
import static clc.common.Constants.NEW_LINE;
import static clc.common.Constants.DisplayOutput;
import static clc.common.Constants.LOG_SEARCH_STARTED;


public class Search implements Command {
	
	String commandDetails;
    private StringBuilder feedback = new StringBuilder();
	private ArrayList<Task> internalMem;
	private ArrayList<Integer> displayMem;
	
	public Search(String commandDetails){
		this.commandDetails = commandDetails;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	}
	public String execute() {
		searchAndprocessOutput();
		appendTaskSearchMessage(feedback, getFeedbackToUser());
		assert feedback != null;
		return feedback.toString();
	}
   
	// Search the internal memory for the keyword and process the output
	private void searchAndprocessOutput() {
		
	    //before searching DisplayOutput and displayMem must be cleared
		DisplayOutput.clear();
		displayMem.clear();
		DisplayOutput.add(String.format(MESSAGE_MATCHING_ENTRIES, commandDetails));
		DisplayOutput.add(EMPTY_STRING);
		
		LogHelper.info(LOG_SEARCH_STARTED);
		if (!internalMem.isEmpty()) {
			sortTasks();
			int displayNo = 1;
			for (int i = 0; i < internalMem.size(); i++) {
				Task task = internalMem.get(i);
				if (task.getTaskName().toLowerCase().contains(commandDetails.toLowerCase())) {
			    	DisplayOutput.add(String.format(MESSAGE_OUTPUT_TASKS, displayNo, task.toString()));	
					displayMem.add(i);
					displayNo++;
				}	
			}
		}
		appendDisplayOutputMessage();
	}

	// Get the feedback according to the result of search
	private String getFeedbackToUser() {
		if (getDataAmount() > 0) {
			if (commandDetails.equals(EMPTY_STRING)) {
				return MESSAGE_RESULTS_FOUND + MESSAGE_DISPLAY;
			} else if (getDataAmount() > 1) {
				return MESSAGE_RESULTS_FOUND + String.format(MESSAGE_SEARCH_FEEDBACK_PLURAL, commandDetails);
			} else {
				return MESSAGE_RESULTS_FOUND + String.format(MESSAGE_SEARCH_FEEDBACK_SINGULAR, commandDetails);
			}
		} else {
			return String.format(ERROR_TASK_NOT_FOUND, commandDetails);
		}
	}
	
	private int getDataAmount() {
		return displayMem.size();
	}
	
	private void sortTasks() {
		Collections.sort(internalMem, new  TaskComparator());
	}
	
	private void appendTaskSearchMessage(StringBuilder feedback, String feedbackMessage) {
		feedback.append(NEW_LINE);
		feedback.append(feedbackMessage);
		feedback.append(NEW_LINE);
	}
	
	private void appendDisplayOutputMessage(){
		for (int i = 0; i < DisplayOutput.size(); i++) {
			feedback.append(DisplayOutput.get(i));
			feedback.append(NEW_LINE);
		}
	}
}

	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Search.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Task.java
	 */

	public String toString(){

		if(taskType == TYPE_TIMED_TASK){
			String startTimeString = D_M_Y_DateFormatter.format(startTime.getTime());
			String endTimeString = D_M_Y_DateFormatter.format(endTime.getTime());
			taskToString = String.format(TIMED_TASK_TO_STRING, taskName, startTimeString, endTimeString);
		}else if (taskType == TYPE_DEADLINE_TASK) {
			String endTimeString = D_M_Y_DateFormatter.format(endTime.getTime());
			taskToString = String.format(DEADLINE_TASK_TO_STRING, taskName, endTimeString);
		}else {
			taskToString = String.format(FLOATING_TASK_TO_STRING, taskName);
		}
		return taskToString;
	}

	public String toStringTimeFormatter(){
		if(taskType == TYPE_TIMED_TASK){
			String startTimeString = D_M_Y_TimeFormatter.format(startTime.getTime());
			String endTimeString = D_M_Y_TimeFormatter.format(endTime.getTime());
			taskToString = String.format(TIMED_TASK_TO_STRING, taskName, startTimeString, endTimeString);
		}else if (taskType == TYPE_DEADLINE_TASK) {
			String endTimeString = D_M_Y_TimeFormatter.format(endTime.getTime());
			taskToString = String.format(DEADLINE_TASK_TO_STRING, taskName, endTimeString);
		}else {
			taskToString = String.format(FLOATING_TASK_TO_STRING, taskName);
		}
		return taskToString;
	}

	public String taskTypeToString(){
		if(taskType == TYPE_TIMED_TASK){
			taskTypeToString = STRING_TIMED_TASK;
		}else if (taskType == TYPE_DEADLINE_TASK) {
			taskTypeToString = STRING_DEADLINE_TASK;
		}else if (taskType == TYPE_FLOATING_TASK){
			taskTypeToString = STRING_FLOATING_TASK;
		}else {
			taskTypeToString = STRING_UNSUPPORTED_TASK;
		}
		return taskTypeToString;
	}

	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Task.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Task.java
	 */

class TaskComparator implements Comparator<Task> {
	@Override
	public int compare(Task task1, Task task2) {
		if(task1.isFloatingTask()){
			if(task2.isFloatingTask()) {
				return task1.getTaskName().compareTo(task2.getTaskName());
			}
			else {
				return -1;
			}
		}
		else {
			if(task2.isFloatingTask()) {
				return 1;
			}
			else if(!task1.getEndTime().equals(task2.getEndTime())) {
				if(task1.getEndTime().before(task2.getEndTime())) {
					return -1;
				}
				else {
					return 1;
				}
			}
			else {
				return task1.getTaskName().compareTo(task2.getTaskName());
			}
		}
	}
}



	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Task.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Update.java
	 */

/**
 * This class is used to update new information to task.
 * 
 */

import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;

import static clc.common.Constants.MESSAGE_TASK_NAME_UPDATED_SUCCESS; 
import static clc.common.Constants.MESSAGE_TASK_STARTTIME_UPDATED_SUCCESS;
import static clc.common.Constants.MESSAGE_TASK_ENDTIME_UPDATED_SUCCESS;
import static clc.common.Constants.MESSAGE_TASK_TYPE_CHANGED;
import static clc.common.Constants.MESSAGE_NO_TASK_TO_UPDATE;
import static clc.common.Constants.MESSAGE_INEXISTANCE_SEQNO;
import static clc.common.Constants.MESSAGE_NO_CHANGE;
import static clc.common.Constants.TYPE_FLOATING_TASK;
import static clc.common.Constants.TYPE_DEADLINE_TASK;
import static clc.common.Constants.TYPE_TIMED_TASK;
import static clc.common.Constants.MESSAGE_FLOATING_TASK_UPDATED_ERROR;
import static clc.common.Constants.MESSAGE_UPDATE_TIME_ERROR;
import static clc.common.Constants.NEWLINE;
import static clc.common.Constants.D_M_Y_DateFormatter;

import clc.common.InvalidInputException;
import clc.common.LogHelper;
import clc.storage.History;
import clc.storage.Storage;


public class Update implements Command {
	
    private int seqNo;
    private int caseCalendarProvided;
    private Task task; 
    private Task taskCopy;
    private String newTaskName = null;
    private StringBuilder feedback = new StringBuilder();
    private ArrayList<GregorianCalendar> time;
    private Calendar newStartTime = null, newEndTime = null;
    private ArrayList<Integer> displayMem;
    private ArrayList<Task> internalMem;
   
	//constructor
	public Update(int seqNo, String newTaskName) {
		this.seqNo = seqNo;
		this.newTaskName = newTaskName;
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	}
	public Update(int seqNo, int caseCalendarProvided, ArrayList<GregorianCalendar> time){
		this.seqNo = seqNo;
		this.caseCalendarProvided = caseCalendarProvided;
		this.time = time;
		newStartTime = time.get(0);
		newEndTime = time.get(1);
		internalMem = Storage.getInternalMem();
		displayMem = Storage.getDisplayMem();
	}
	
	@Override
	public String execute() {
		if (isDataEmpty()) {
			appendTaskUpdatedMessage(feedback, MESSAGE_NO_TASK_TO_UPDATE);
			
		} else if (isOutOfBound()) {
			appendTaskUpdatedMessage(feedback, MESSAGE_INEXISTANCE_SEQNO);
			
		} else {
			int internalSeqNo = displayMem.get(seqNo - 1);
			task = internalMem.get(internalSeqNo);
			taskCopy = task.getNewCopy();
			
		    try {    
			    updateTask();
				taskIfStartTimeLaterThanOrEqualToEndTime(task);
				
			} catch (InvalidInputException iie) {
	            internalMem.set(internalSeqNo, taskCopy);
				return iie.getMessage();
			}
            
            //have a backup for undo operation
    		History.addNewVersion();
    		Storage.writeContentIntoFile();
		}
		
		assert feedback != null;
		return feedback.toString();
	}
	
	private void updateTask() throws InvalidInputException{
		
		String taskName = task.getTaskName();
		int taskOldType = task.getTaskType();
		String taskOldTypeString = task.taskTypeToString();
        Calendar taskOldStartTime = task.getStartTime(); 
		Calendar taskOldEndTime = task.getEndTime();
		
		Calendar updateTime = null;
		Calendar floatingTaskStartTime = null;
		
		//update name
		if (isUpdatedNameCase(newTaskName)){
			updateTaskName(taskName, newTaskName);
		}
		
		//update start time
		if (isUpdatedStartTimeCase(newStartTime)){
			
			if (taskOldType == TYPE_TIMED_TASK){//for timed task
				//update date
				if (isStartDateUpdated(caseCalendarProvided)) {
					updateTime = updateNewDate(taskOldStartTime, newStartTime);
				    task.setStartTime(updateTime);
				    caseCalendarProvided -= 8;
				} 
				//update time
				if (isStartTimeUpdated(caseCalendarProvided)) {
					updateTime = task.getStartTime();
					updateTime = updateNewTime(updateTime, newStartTime);
				    task.setStartTime(updateTime);
				    caseCalendarProvided -= 4;
				}
				//process feedback
				appendTaskStartTimeUpdatedMessage(feedback, task, seqNo);
				
			} else if (taskOldType == TYPE_DEADLINE_TASK){//for deadline task
				task.setStartTime(newStartTime);
				updateTime = task.getStartTime();
				task.setTaskType(TYPE_TIMED_TASK);
				caseCalendarProvided %= 4;
				
				//process feedback
				appendTaskStartTimeUpdatedMessage(feedback, task, seqNo);

				
			} else {//for floating task
				if(newEndTime != null){
					task.setStartTime(newStartTime);
					updateTime = task.getStartTime();
					
					//process feedback
					appendTaskStartTimeUpdatedMessage(feedback, task, seqNo);
					
				} else {
					LogHelper.warning("user updates floating task's start time only");
					throw new InvalidInputException(MESSAGE_FLOATING_TASK_UPDATED_ERROR);
				}
			}
			
		}
		
		//update end time
		if (isUpdatedEndTimeCase(newEndTime)) {
			if (taskOldType == TYPE_FLOATING_TASK){//for floating task
				floatingTaskStartTime = task.getStartTime();
				if (floatingTaskStartTime == null){
					task.setEndTime(newEndTime);
					updateTime = task.getEndTime();
					task.setTaskType(TYPE_DEADLINE_TASK);	
					
				} else {
					task.setEndTime(newEndTime);
					updateTime = task.getEndTime();
					task.setTaskType(TYPE_TIMED_TASK);
				}
			} else { // for deadline & timed task
				
				//update date
				if (isEndDateUpdated(caseCalendarProvided)) {
					updateTime = updateNewDate(taskOldEndTime, newEndTime);
				    task.setEndTime(updateTime);
				    caseCalendarProvided -= 2;
				} 
				
				//update time
				if (isEndTimeUpdated(caseCalendarProvided)) {
					updateTime = task.getEndTime();
					updateTime = updateNewTime(updateTime, newEndTime);
				    task.setEndTime(updateTime);
				}
			}
			// process feedback
			appendTaskEndTimeUpdatedMessage(feedback, task, seqNo);
		} 

		//check if task type changed
		int taskNewType = task.getTaskType();
		String taskNewTypeString = task.taskTypeToString();
		if(isTaskTypeChanged(taskOldType, taskNewType)){
			LogHelper.warning(String.format(MESSAGE_TASK_TYPE_CHANGED, seqNo ,taskName, taskOldTypeString, taskNewTypeString));
		}
		
		//check if nothing changes
		if(newTaskName == null && newStartTime == null && newEndTime == null){
			appendTaskUpdatedMessage(feedback, MESSAGE_NO_CHANGE);
		}
	}
	
	private GregorianCalendar updateNewDate(Calendar oldTime, Calendar newTime) {
		int year = newTime.get(Calendar.YEAR);
	 	int month =	newTime.get(Calendar.MONTH);	
		int date = newTime.get(Calendar.DATE);
		int hour = oldTime.get(Calendar.HOUR_OF_DAY);
		int minute = oldTime.get(Calendar.MINUTE);
		GregorianCalendar dateUpdated = new GregorianCalendar(year, month, date, hour, minute);
		return dateUpdated;
	}
	
	private GregorianCalendar updateNewTime(Calendar oldTime, Calendar newTime){
	    return updateNewDate(newTime, oldTime);
	}
	
	private void updateTaskName(String taskOldName, String taskNewName){
            task.setTaskName(taskNewName);
            appendTaskUpdatedNewNameMessage(feedback, taskOldName, taskNewName);
	} 
	
    //append feedback method
	private void appendTaskUpdatedMessage(StringBuilder feedback, String message) {
		feedback.append(message);
		feedback.append(NEWLINE);
	}
	
	private void appendTaskUpdatedNewNameMessage(StringBuilder feedback, String taskOldName, String taskNewName) {
	       feedback.append(String.format(MESSAGE_TASK_NAME_UPDATED_SUCCESS, taskOldName, taskNewName));
           feedback.append(NEWLINE);
	}
	
	private void appendTaskStartTimeUpdatedMessage(StringBuilder feedback,Task task, int seqNo){
		String taskName = task.getTaskName();
		String startTime = D_M_Y_DateFormatter.format(task.getStartTime().getTime());
		feedback.append(String.format(MESSAGE_TASK_STARTTIME_UPDATED_SUCCESS, taskName, startTime, seqNo));
		feedback.append(NEWLINE);
	}
	
	private void appendTaskEndTimeUpdatedMessage(StringBuilder feedback,Task task, int seqNo){
		String taskName = task.getTaskName();
		String endTime = D_M_Y_DateFormatter.format(task.getEndTime().getTime());
		feedback.append(String.format(MESSAGE_TASK_ENDTIME_UPDATED_SUCCESS, taskName, endTime, seqNo));
		feedback.append(NEWLINE);
	}
    
    // check if task start time is later or equal than task end time, throw error message
	private static void taskIfStartTimeLaterThanOrEqualToEndTime(Task task) throws InvalidInputException {
		Calendar startTime = task.getStartTime();
		Calendar endTime = task.getEndTime();
		if (startTime != null && startTime.compareTo(endTime) >= 0) {
			LogHelper.warning("Start time is later than or equal to end time");
			throw new InvalidInputException(MESSAGE_UPDATE_TIME_ERROR);
		}
	}
	
	private boolean isDataEmpty() {
		return displayMem.isEmpty();
	}
	
	private boolean isOutOfBound() {
		return seqNo > displayMem.size();
	}
	
	
	private boolean isTaskTypeChanged(int taskOldType, int taskNewType) {
		return taskOldType != taskNewType;
	}
	
	private boolean isUpdatedNameCase(String taskNewName){
		return taskNewName != null;
	}
	
	private boolean isUpdatedStartTimeCase(Calendar newStartTime){
		return newStartTime != null;
	}
	
	private boolean isUpdatedEndTimeCase(Calendar newEndTime){
		return newEndTime != null;
	}
	
	private boolean isStartDateUpdated(int caseCalendarProvided) {
		return caseCalendarProvided/8 == 1;
	}
	
	private boolean isStartTimeUpdated(int caseCalendarProvided) {
		return caseCalendarProvided/4 == 1;
	}
	
	private boolean isEndDateUpdated(int caseCalendarProvided) {
		return caseCalendarProvided/2 == 1;
	}
	private boolean isEndTimeUpdated(int caseCalendarProvided) {
		return caseCalendarProvided == 1;
	}
}	

	
	
	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\logic\Update.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\storage\Storage.java
	 */

	/**
	 * Create the data file if it does not exist. 
	 * Otherwise read in the content from the data file.
	 */
	
	public static void initializeDataFile() {
		dataFile = new File(OUTFILE);
		if (!dataFile.exists()) {
			// Create the file if it does not exist
			try {
				dataFile.createNewFile();
				LogHelper.info(String.format(LOG_DATA_FILE_CREATED, dataFile.getPath()));
			} catch (IOException e) {
				LogHelper.severe(e.getMessage());
			}
		} else {
			try {
				readContentFromFile(OUTFILE);
			} catch (Exception e) {
				LogHelper.severe(e.getMessage());
			}
		}
		
		assert dataFile.exists();
	}
	
	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\storage\Storage.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\storage\Storage.java
	 */

	/**
	 * Read from the Help.txt and return to string
	 * @param fileName The file name of help manual file
	 * @return The contents of the help manual file
	 */
	public static String readManualFromHelpFile(String fileName) {
		InputStream in = Storage.class.getResourceAsStream(fileName);
		
		StringBuilder sb = new StringBuilder();
		try {

			BufferedReader bf = new BufferedReader(new InputStreamReader(in));
			String contentToRead = null;

			while((contentToRead = bf.readLine()) != null) {
				sb.append(contentToRead);
				sb.append(NEWLINE);
			}

			bf.close();
			LogHelper.info(String.format(LOG_DATA_FILE_READ, fileName));
		} catch (IOException e) {
			LogHelper.severe(e.getMessage());
		}
		return sb.toString();
	}
	
	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\clc\storage\Storage.java





	/**
	 * origin: D:\Dropbox\workspace\cs2103jan2014-w13-2j\test\SystemTest.java
	 */

/**
 * This is the overall test for the whole system
 * 
 */

import static org.junit.Assert.*;
import clc.ui.UserInterface;
import clc.storage.Storage;
import clc.logic.Task;

import java.util.ArrayList;
import java.util.Calendar;

import org.junit.Before;
import org.junit.Test;

public class SystemTest {
	ArrayList < String > inputList = new ArrayList < String >();
	ArrayList < String > feedbackList = new ArrayList < String >();
	String actualFeedback = null;
	UserInterface start = new UserInterface();
	Calendar date = Calendar.getInstance();
	ArrayList<Integer> displayMem = Storage.getDisplayMem();
	ArrayList<Task> internalMem = Storage.getInternalMem();
	@Before
	public void setUp() throws Exception {
		// Test case 1: Add
		inputList.add("add buy ticket 31/12 2pm");
		feedbackList.add("buy ticket(ending at Wed, 31 Dec 2014 2.00 PM) is added.");
        
		// Test case 2: Update
		date.set(2014, 3, 2, 14, 0, 0);
		//System.out.println(date.getTime());
		displayMem.clear();
		internalMem.add(new Task("buy ticket", date));
		displayMem.add(internalMem.size());
		inputList.add("update 1 , 03/04");
		feedbackList.add("Task No.1 [buy ticket] end  time is updated to [Thu, 3 Apr 2014 2.00 PM] successfully.\n");
		
		// Test case 3: Delete 
		inputList.add("delete 1");
		feedbackList.add("[buy ticket] is deleted.\n");
		
		// Test case 4: Undo
		inputList.add("undo");
		feedbackList.add("Last command has been undone.");
		
		// Tast case 5: Redo
		inputList.add("redo");
		feedbackList.add("Last command has been redone.");
		inputList.add("undo");
		feedbackList.add("Last command has been undone.");
		
		
		//Test case 6: Mark
		inputList.add("mark 1");
		
		feedbackList.add("mark [buy ticket] as done successfully.");
		
		//Test case 7: Unmark
		inputList.add("unmark 1");
		feedbackList.add("mark [buy ticket] as not done sucessfully");
		
		//Test case 8: Invalid Command 
		inputList.add("unso");
		feedbackList.add("Invalid command format: unso");
	}
	
	@Test
	public void test() {	
		for(int i = 0; i < inputList.size(); i++) {
			actualFeedback = UserInterface.setInputAndExecute(inputList.get(i));
			assertEquals(feedbackList.get(i), actualFeedback);
		}
	}
}

	// End of segment: D:\Dropbox\workspace\cs2103jan2014-w13-2j\test\SystemTest.java





